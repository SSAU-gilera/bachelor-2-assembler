// Asm_3.cpp : Этот файл содержит функцию "main". Здесь начинается и заканчивается выполнение программы.
//

#include <iostream>
#include <stdio.h> // стандартный ввод/вывод
#include <iostream>
using namespace std;
int* calculator(int mas[], int n)
{
	int* result = new int[n];
	bool excep = 0;
	__asm {
		//запускаем цикл по массиву, чтобы найти сумму отрицательных и минимальный элемент
		mov	esi, mas;				esi указывает на начало массива mas[]
		mov ebx, 0;					промежуточный результат суммы
		mov	ecx, n;					счётчик цикла по всем элементам массива
		jcxz success;				перейти к мтеик success если длина массива ноль
		mov	eax, -100000;				определяем первый элемент(далее - максимальный)
		begin1_loop:
		mov	edx, [esi];				определяем текущий элемент массива mas[]
			//сумма нечетных элементов
			test edx, 1
			jnz nechet;
		jz onward;					четное, переход на метку onward
			nechet :
		add ebx, edx;				<ebx> = <ebx> +<edx>
			jmp end1_loop;
	onward:
		//максимальный элемент
		cmp edx, eax;				сравниваем текущий элемент с max
			jl end1_loop;			если текущий элемент меньше максимального, переходим к метке end1_loop
			mov eax, edx;			иначе присваиваем новый максимальный элемент
			end1_loop :
		add esi, 4;					переходим к следующему элементу массива mas[]
			loop begin1_loop;			повторяем цикл для всех элементов массива
			add eax, 0;					проверяем максимальный элемент на равенство нулю
			jz error;					переходим к метке error, если знаменатель равен нулю
			push eax;					загружаем mах элемент в стек
			push ebx;					загружаем сумму нечетных элементов в стек
			//запускаем цикл по массиву, чтобы получить новый массив
			mov	esi, mas;				esi указывает на начало массива mas[]
			mov edi, result;			edi указывает на начало массива result[]
			mov	ecx, n;					счётчик цикла по всем элементам массива
			pop ebx;					извлекаем из вершины стека сумму нечетных элементов в регистр <ebx>
			pop n;						извлекаем из вершины стека максимальный элемент в переменную n
			begin3_loop :
		mov eax, [esi];				определяем текущий элемент массива mas[]
			add eax, ebx;				<eax> = (a[i] + сумма нечетных элементов)
			cdq;						подготовка к делению
			idiv n;						<eax> = (a[i] + сумма нечетных элементов) / максимальный элемент
			mov[edi], eax;				записываем полученный элемент в массив result[]
			end3_loop:
		add esi, 4;					переходим к следующему элементу массива mas[]
			add edi, 4;					переходим к следующему элементу массива result[]
			loop begin3_loop;			повторяем цикл для всех элементов массива
			jmp success;				переход без условия
			error :
		mov excep, 1;
	success:
	}
	if (excep) throw exception("Попытка деления на ноль!");
	return result;
}


void main()
{
	while (true) {
		system("cls");
		int n;
		setlocale(LC_ALL, "");
		cout << "Гижевская Лера\nГруппа 6113\nВариант 52" << endl;
		cout << "Задание:" << endl;
		cout << "Сформировать новый массив из одномерного массива A={a[i]} целых чисел по следующему правилу:" << endl << endl;
		cout << "a[i] = (a[i] + сумма нечетных элементов)/максимальный элемент" << endl;
		cout << "Введите длину массива: ";
		cin >> n;
		int* mas1 = new int[n];
		int* mas2 = new int[n];
		int* mas3 = new int[n];
		cout << endl;
		cout << "Введите элементы массива: " << endl;
		for (int i = 0; i < n; i++) { cin >> mas1[i]; mas3[i] = mas1[i]; }
		cout << endl;
		try {
			mas2 = calculator(&*mas1, n);
			cout << "Assembler : ";
			for (int i = 0; i < n; i++) cout << mas2[i] << " ";
		}
		catch (exception e) { cout << e.what(); }
		cout << "\nРезультат С++ : ";
		int sum = 0;
		bool f = false;
		int max;
		for (int i = 0; i < n; i++) {
			if (mas3[i] % 2 == 0) {
				if (!f) {
					f = true;
					max = mas3[i];
				}
				if (mas3[i] > max)
				{
					max = mas3[i];
				}
			}
			else sum += mas3[i];
		}
		for (int i = 0; i < n; i++) {
			if (max != 0) {
				mas3[i] = (mas3[i] + sum) / max;
				cout << mas3[i] << " ";
			}
			else cout << "Деление на ноль!" << endl;
		}
		cout << "\nСумма нечетных элементов : " << sum << endl;
		cout << "\nМаксимальный элемент : " << max << endl;
		system("PAUSE");
	}
}

// Запуск программы: CTRL+F5 или меню "Отладка" > "Запуск без отладки"
// Отладка программы: F5 или меню "Отладка" > "Запустить отладку"

// Советы по началу работы 
//   1. В окне обозревателя решений можно добавлять файлы и управлять ими.
//   2. В окне Team Explorer можно подключиться к системе управления версиями.
//   3. В окне "Выходные данные" можно просматривать выходные данные сборки и другие сообщения.
//   4. В окне "Список ошибок" можно просматривать ошибки.
//   5. Последовательно выберите пункты меню "Проект" > "Добавить новый элемент", чтобы создать файлы кода, или "Проект" > "Добавить существующий элемент", чтобы добавить в проект существующие файлы кода.
//   6. Чтобы снова открыть этот проект позже, выберите пункты меню "Файл" > "Открыть" > "Проект" и выберите SLN-файл.
